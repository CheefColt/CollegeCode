
const codeObject = { 
    "Semesters":[
        {
            "1": []
        },
        {
            "2": []
        },
        {
            "3":[ {"OS": [{ "E1": ""},{ "E2": ""}]},
            {
                "DS": [ {"E1": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nstruct Day{\n    char* dayName;\n    int date;\n    char *desc;\n};\n\ntypedef struct Day D;\n\nD create(){\n    D newDay;\n\n    newDay.dayName = (char*)malloc(20*sizeof(char));\n    newDay.desc = (char*)malloc(20*sizeof(char));\n\n    printf(\"Enter the Day name: \");\n    scanf(\"%s\",newDay.dayName);\n\n    printf(\"Enter the date: \");\n    scanf(\"%d\",&newDay.date);\n\n    printf(\"Enter the description: \");\n    scanf(\"%s\",newDay.desc);\n\n    return newDay;\n}\n\nvoid read(D calender[],int nD){\n\n    for(int i=0; i<nD; i++){\n        printf(\"\\nEnter the details for Day %d: \\n\",i+1);\n        calender[i] = create();\n    }\n}\n\nvoid display(D calender[], int nD){\n\n    printf(\"\\n---------------------------Calender--------------------------------------\\nDay\\t\\t\\tDate\\t\\tDescription\\n\\n\");\n    for(int i=0; i<nD; i++){\n        printf(\"%s\\t\\t\\t%d\\t\\t%s\\n\",calender[i].dayName,calender[i].date,calender[i].desc);\n    }\n\n    printf(\"\\n\\n\");\n}\n\nint main(){\n    int nD = 2;\n\n    D calender[nD];\n\n    read(calender,nD);\n    display(calender,nD);\n        "},
                        {"E2": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\nchar str[100],pat[100],rep[100];\n\nint pat_len;\n\nvoid read_strings(){\n    int i = 0;\n    printf(\"\\nEnter the main string: \");\n    gets(str);\n\n    printf(\"\\nEnter the pattern string: \");\n    gets(pat);\n\n    printf(\"\\nEnter the replacement string: \");\n    gets(rep);\n\n    while(pat[i]!='\\0'){\n        pat_len++;\n        i++;\n    }\n}\n\nvoid pattern_match(){\n\n    int i,j,k,z = 0;\n    int count = 0;\n\n    char final_str[100];\n\n    for(i=0; str[i]!='\\0'; i++){\n        j = 0;\n        while((str[i+j]==pat[j]) && (j<pat_len))\n            j++;\n        \n        if(pat[j]=='\\0'){\n            count++;\n            for(k=0; rep[k]!='\\0';k++,z++){\n                final_str[z] = rep[k];\n            }\n            i = i+pat_len-1;\n        }\n        else{\n            final_str[z++] = str[i];\n        }\n    }\n\n    if(count==0){\n        printf(\"\\nPattern does not exist in main string!\");\n    }\n    else{\n        final_str[z] = '\\0';\n        printf(\"\\nNo of occurances of pattern in main string: %d\\n\",count);\n        printf(\"The main string after replacement is: \\n%s\",final_str);\n    }\n}\n\nint main(){\n\n    read_strings();\n    pattern_match();\n    return 0;\n}   "},
                        {"E3": "#include<stdio.h>\n#define MAX 5\n\nint top = -1;\nint s[MAX];\n\nvoid push(int n){\n    if(top==MAX-1){\n        printf(\"\\nStack overflow.\");\n    }\n    else{\n        s[++top] = n;\n    }\n}\n\nint pop(){\n\n    if(top==-1){\n        printf(\"\\nStack is empty.\");\n        return -1;\n    }\n    else{\n        int p = s[top--];\n        return p;\n    }\n}\n\nvoid palindrome(){\n\n    int n,i,p[10],flag = 0;\n\n    printf(\"\\nEnter the number of digits: \");\n    scanf(\"%d\",&n);\n\n    printf(\"\\nEnter the digits: \");\n    for(i = 0; i<n; i++){\n        scanf(\"%d\",&p[i]);\n        push(p[i]);\n    }\n\n    for(i = 0; i<n; i++){\n        if(p[i]!=pop()){\n            flag = 1;\n            break;\n        }\n    }\n\n    if(flag==0){\n        printf(\"\\nPalindrome.\");\n    }\n    else{\n        printf(\"\\nNot palindrome.\");\n    }\n\n}\n\nvoid display(){\n    int i = 0;\n    if(top==-1){\n        printf(\"\\nStack is empty!\");\n    }\n    else{\n        printf(\"\\nThe elements of stack are: \");\n        for(i = top; i>=0; i--){\n            printf(\"\\t%d\",s[i]);\n        }\n    }\n}\n\nint main(){\n    int ch,elem,del_elem,flag;\n\n    for(;;){\n        printf(\"\\n-----------------------------------------------------\");\n        printf(\"\\t\\tStack Operations\");\n        printf(\"\\n1.Push\\t2.Pop\\t3.Check Palindrome\\t4.Display\\t5.Exit\");\n        printf(\"\\n-----------------------------------------------------\");\n        printf(\"\\nEnter your choice: \");\n        scanf(\"%d\",&ch);\n        printf(\"\\n\");\n\n        switch(ch){\n            case 1: printf(\"\\nEnter element to push: \");\n                    scanf(\"%d\",&elem);\n                    push(elem);\n                    break;\n            case 2:\n                    del_elem = pop();\n                    if(del_elem == -1){\n                        printf(\"\\nNo element deleted.\");\n                    }\n                    else{\n                        printf(\"\\nThe deleted element is: %d\",del_elem);\n                    }\n                    break;\n            case 3:\n                    palindrome();\n                    break;\n            case 4: display();\n                    break;\n            case 5:\n                    return 0;\n            default: printf(\"\\nInvalid choice, try again!\");\n                    break;\n\n        }\n    }\n    return 0;\n}"},
                        {"E4": "#include<stdio.h>\n#include<stdlib.h>\n#include<ctype.h>\n#define MAX 30\n\nint top = -1;\nchar s [MAX];\n\nvoid push(char ele)\n{\n    if(top == MAX-1)\n        printf(\"\nStack Overflow!!\n\");\n    else\n    {\n        top++;\n        s[top] = ele;\n    }\n}\n\nchar pop()\n{\n    char d;\n\n    if(top==-1)\n    {\n        printf(\"\nStack Underflow!!\n\");\n        return -1;\n    }\n    else\n    {\n        d = s[top];\n        top--;\n        return d;\n    }\n}\n\nint priority(char c)\n{\n    if(c=='(')\n        return 1;\n    else if(c=='+' || c=='-')\n        return 2;\n    else if(c=='*'||c=='/'||c=='%')\n        return 3;\n    else if(c=='^'||c=='$')\n        return 4;\n    else\n        return 0;\n}\n\nint main()\n{\n    char in[MAX], po[MAX];\n    int i;\n    int j = 0;\n\n    printf(\"\nEnter the infix expression: \");\n    scanf(\"%s\", in);\n\n    for(i=0;in[i]!='\\0';i++)\n    {\n        if(isalnum(in[i]))\n        {\n             po[j] = in[i];\n             j++; // po[j++] = in[\n        }\n        else if(in[i]=='(')\n        {\n            push(in[i]);\n        }\n        else if(in[i]==')')\n        {\n            while(s[top]!='(')\n            {\n                po[j] = pop();\n                j++; // po[j++] = pop()\n            }\n            pop(); //top--;\n        }\n        else\n        {\n            while( priority(s[top]) >= priority(in[i]) )\n            {\n                po[j] = pop();\n                j++;    // po[j++] = pop()\n            }\n\n            push(in[i]);\n        }\n    }\n\n    while(top!=-1)\n    {\n        po[j] = pop();\n        j++;    // po[j++] = pop()\n    }\n\n    po[j] = '\\0';\n    printf(\"\nThe postfix expression is: %s\", po);\n\n    return 0;\n}\n"},
                        {"E5": "#include<stdio.h>\n#define MAX 30\n#include<ctype.h>\n#include<math.h>\n\nint top = -1;\ndouble s [MAX];\n\nvoid push(double ele)\n{\n    if(top == MAX-1)\n        printf(\"\nStack Overflow!!\n\");\n    else\n    {\n        top++;\n        s[top] = ele;\n    }\n}\n\ndouble pop()\n{\n     double d;\n\n    if(top==-1)\n    {\n        printf(\"\nStack Underflow!!\n\");\n        return -1;\n    }\n    else\n    {\n        d = s[top];\n        top--;\n        return d;\n    }\n}\n\ndouble evaluate(char c, double op1, double op2)\n{\n    switch(c)\n    {\n        case '+': return op1 + op2;\n\n        case '-': return op1 - op2;\n\n        case '*': return op1 * op2;\n\n        case '/': return op1 / op2;\n\n        case '%': return fmod(op1,op2);\n\n        case '^': return pow(op1,op2);\n\n    }\n}\n\nint main()\n{\n    char suf[MAX];\n    int i;\n    double v, op1, op2, r;\n\n    printf(\"\nEnter the suffix/postfix expression: \");\n    scanf(\"%s\", suf);\n\n    for(i=0; suf[i]!='\\0'; i++)\n    {\n        if(isalpha(suf[i]))\n        {\n            printf(\"\nEnter the value of %c: \", suf[i]);\n            scanf(\"%lf\",&v);\n            push(v);\n        }\n        else if(isdigit(suf[i]))\n        {\n            push(suf[i] - '0');\n        }\n        else\n        {\n            op2 = pop();\n            op1 = pop();\n            r = evaluate(suf[i], op1, op2);\n            push(r);\n        }\n    }\n\n    printf(\"\nThe result is %lf\", pop());\n\n    return 0;\n}"            },
                        {"E6": "#include<stdio.h>\n#define M 5\n\nint f = -1;\nint r = -1;\n\nvoid insert(char cq[M]){\n    char ele;\n    printf(\"\nEnter the element to insert: \");\n    scanf(\"\n%c\",&ele);\n    if((f == 0 && r==M-1)||(f==r+1)){\n        printf(\"\nQueue overflow!\");\n        return;\n    }   \n    if(f==-1)\n        f = 0;\n    r = (r+1)%M;\n    cq[r] = ele;\n}\n\n\nvoid delete(char cq[M]){\n    if(f==-1){\n        printf(\"\nQueue overflow!\");\n        return;\n    }\n    printf(\"\nThe deleted element is: %c\",cq[f]);\n    if(f==r){\n        f = -1; r = -1;\n    }\n    else{\n        f = (f+1)%M;\n    }\n}\n\nvoid display(char cq[M]){\n    int i;\n    if(f==-1){\n        printf(\"\nQueue underflow!\");\n    }\n    else{\n        printf(\"\nThe element of queue are: \");\n        for(i=f;i!=r;i=((i+1)%M))\n            printf(\"\t%c\",cq[i]);\n        printf(\"\t%c\",cq[i]);\n    }\n}\n\nint main(){\n    int ch;\n    char cq[M];\n\n    for(;;){\n        printf(\"\n---------------------------------\");\n        printf(\"\nCircular Queue Operations\");\n        printf(\"\n1.Insert\t2.Delete\t3.Display\t4.Exit\");\n        printf(\"\n---------------------------------\");\n        printf(\"\nEnter the choice: \");\n        scanf(\"%d\",&ch);\n\n        switch (ch)\n        {\n        case 1:\n            insert(cq);\n            break;\n        case 2:\n            delete(cq);\n            break;\n        case 3:\n            display(cq);\n            break;\n        case 4:\n            return 0;\n        default:\n            printf(\"\nInvalid choice, try again!\");\n        }\n    }\n    return 0;\n}"            },
                        {"E7": "#include<stdio.h>\n#include<stdlib.h>\n\nstruct student{\n    char usn[20];\n    char name[20];\n    char program[20];\n    int sem;\n    long int phno;\n    struct student *link;\n};\n\ntypedef struct student* s;\n\ns start = NULL;\n\ns create(){\n    s newNode = (s)malloc(sizeof(struct student));\n    if(newNode==NULL){\n        printf(\"\nThe node is not created!\");\n        return NULL;\n    }\n\n    printf(\"\nEnter the usn: \");\n    scanf(\"%s\",newNode->usn);\n\n    printf(\"\nEnter the name: \");\n    scanf(\"%s\",newNode->name);\n\n    printf(\"\nEnter the program: \");\n    scanf(\"%s\",newNode->program);\n\n    printf(\"\nEnter the semester: \");\n    scanf(\"%d\",&newNode->sem);\n\n    printf(\"\nEnter the phone number: \");\n    scanf(\"%ld\",&newNode->phno);\n\n    newNode -> link = NULL;\n\n    return newNode;\n\n}\n\nvoid iF(){\n    s newNode = create();\n\n    if(start==NULL){\n        start = newNode;\n    }\n    else{\n        newNode->link = start;\n        start = newNode;\n    }\n}\n\nvoid display(){\n\n    s temp = start;\n\n    if(temp==NULL){\n        printf(\"\nList is empty.\");\n    }\n    else{\n        int count = 0;\n        while(temp!=NULL){\n            count++;\n            printf(\"\nUSN: %s\tName: %s\tProgramme: %s\tSemester: %d\tPhone No: %ld\",temp->usn,temp->name,temp->program,temp->sem,temp->phno);\n            temp = temp->link;\n        }\n    }\n}\n\nvoid dF(){\n    s temp = start;\n\n    if(temp==NULL){\n        printf(\"\nThe list is empty.\");\n    }\n    else{\n        start = start->link;\n        free(temp);\n    }\n}\n\nvoid iE(){\n\n    s temp = start;\n    s newNode = create();\n\n    if(temp==NULL){\n        start = newNode;\n    }\n    else{\n        while(temp->link!=NULL){\n            temp = temp->link;\n        }\n        temp->link = newNode;\n    }\n}\n\nvoid dE(){\n    s temp = start;\n\n    if(temp==NULL){\n        printf(\"\nThe list is empty\");\n    }\n    else if(temp->link == NULL){\n        free(start);\n        start = NULL;\n    }\n    else{\n        while(temp->link->link!=NULL){\n            temp = temp->link;\n        }\n        free(temp->link);\n        temp -> link = NULL;\n    }\n}\n\nvoid create_l(){\n    int n;\n\n    printf(\"\nEnter the number of students: \");\n    scanf(\"%d\",&n);\n\n    for(int i = 0;i<n; i++){\n        iF();\n    }\n}\n\nvoid stackDemo(){\n    int ch;\n\n    while(1){\n        printf(\"\n-------------------------------------\");\n        printf(\"\nStack Operations\");\n        printf(\"\n1.Insert End\t2.Delete End\t3.Display stack\t4.Exit\");\n        printf(\"\n--------------------------------------\");\n        printf(\"\nEnter your choice: \");\n        scanf(\"%d\",&ch);\n\n        switch (ch)\n        {\n        case 1:\n            iE();\n            break;\n        \n        case 2:\n            dE();\n            break;\n        \n        case 3:\n            display();\n            break;\n\n        default:\n            printf(\"\nInvalid Choice!!\");\n            break;\n        }\n    }\n}\n\nint main(){\n\n    int ch;\n\n    while(1){\n        printf(\"\n-------------------------MENU-----------------------------\");\n        printf(\"\n1.Create list\t2.Insert Front\t3.Delete Front\t4.Insert End\t5.Delete End\t6.Display\t7.Stack Demo\t8.Exit\\nEnter your choice: \");\n        scanf(\"%d\",&ch);\n\n        switch (ch)\n        {\n        case 1:\n            create_l();\n            break;\n        \n        case 2:\n            iF();\n            break;\n        \n        case 3:\n            dF();\n            break;\n        \n        case 4:\n            iE();\n            break;\n        \n        case 5:\n            dE();\n            break;\n\n        case 6:\n            display();\n            break;\n        \n        case 7: \n            stackDemo();\n            break;\n        case 8:\n            return 0;\n        default:\n            printf(\"\nInvalid choice!\");\n            break;\n        }\n    }\n    return 0;\n    \n}"},
                        {"E8": "#include<stdio.h>\n#include<stdlib.h>\n\nstruct employee{\n    char ssn[20], name[20], dept[20],desig[20];\n    int salary;\n    long int phNo;\n    struct employee * llink, *rlink;\n};\n\ntypedef struct employee * E;\n\nE start = NULL;\n\nE create(){\n    E gnode = (E)malloc(sizeof(struct employee));\n\n    if(gnode==NULL){\n        printf(\"\nThe list is not allocated!\");\n        return NULL;\n    }\n    \n    printf(\"\nEnter details: \");\n    printf(\"\nUSN: \");\n    scanf(\"%s\",gnode->ssn);\n\n    printf(\"\nName: \");\n    scanf(\"%s\",gnode->name);\n\n    printf(\"\nDepartment: \");\n    scanf(\"%s\",gnode->dept);\n\n    printf(\"\nDesignation: \");\n    scanf(\"%s\",gnode->desig);\n\n    printf(\"\nSalary: \");\n    scanf(\"%d\",&gnode->salary);\n\n    printf(\"\nPhone Number: \");\n    scanf(\"%ld\",&gnode->phNo);\n\n    gnode->llink = NULL;\n    gnode->rlink = NULL;\n\n    return gnode;\n\n}\n\nvoid insert_end(){\n    E node, temp;\n\n    node = create();\n\n    if(start == NULL)\n        start = node;\n    else{\n        temp = start;\n        while(temp->rlink!=NULL){\n            temp = temp->rlink;\n        }\n        temp->rlink = node;\n        node->llink = temp;\n    }\n    \n}\n\nvoid delete_end(){\n    E temp;\n    temp = start;\n    if(temp==NULL)\n        printf(\"\nList is empty\");\n    else if(temp->rlink == NULL){\n        printf(\"\nThe deleted employee ssn iS: %s\",temp->ssn);\n        free(temp);\n        start = NULL;\n    }\n    else{\n        while(temp->rlink->rlink!=NULL){\n            temp = temp->rlink;\n        }\n        printf(\"\nThe deleted employee ssn iS: %s\",temp->rlink->ssn);\n        free(temp->rlink);\n        temp->rlink = NULL;\n    }\n}\n\nvoid create_list(){\n    int n,i;\n    printf(\"\nEnter the number of employees: \");\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++){\n        insert_end();\n    }\n}\n\nvoid status(){\n    E temp;\n    int count = 0;\n    if(start==NULL){\n        printf(\"\nList is empty.\");\n        return;\n    }\n    temp = start;\n    printf(\"\nThe Employee details are: \");\n\n    while(temp!=NULL){\n        printf(\"\n%s\t%s\t%s\t%s\t%d\t%ld\n\",temp->ssn,temp->name,temp->dept,temp->desig,temp->salary,temp->phNo);\n        temp = temp->rlink;\n        count++;\n    }\n\n    printf(\"\nThe number of nodes are: %d\",count);\n}\n\nvoid insert_front(){\n    E node;\n    node = create();\n\n    if(start==NULL){\n        start = node;\n    }\n    else{\n        node->rlink = start;\n        start->llink = node;\n        start = node;\n    }\n}\n\nvoid delete_front(){\n\n    E temp = start;\n\n    if(temp==NULL){\n        printf(\"\nThe list is empty.\");\n    }\n    else if(temp->rlink==NULL){\n        printf(\"\nThe ssn of the deleted employee is: %s\",start->ssn);\n        free(temp);\n        start = NULL;\n    }\n    else{\n        printf(\"\nThe ssn of the deleted employee is: %s\",temp->ssn);\n        start = start->rlink;\n        free(temp);\n        start->llink = NULL;\n    }\n}\n\nvoid double_ended_queue(){\n    int ch;\n    while(1){\n        printf(\"\n--------------------------Double Ended Queue Operations---------------------------\n\");\n        printf(\"\n1.Insert rear\t2.Delete Rear\t3.Insert Front\t4.Delete Front\t5.Display\t6.Exit\nEnter your choice: \");\n        scanf(\"%d\",&ch);\n\n        switch (ch)\n        {\n        case 1:\n            insert_end();\n            break;\n        case 2:\n            delete_end();\n            break;\n        case 3:\n            insert_front();\n            break;\n        case 4:\n            delete_front();\n            break;\n        case 5:\n            status();\n            break;\n        case 6:\n            return;\n        default:\n            printf(\"\nInvalid choice\");\n            break;\n        }\n    }\n}\n\nint main(){\n\n    int ch;\n\n    while(1){\n        printf(\"\n-----------------DLL Operations --------------------------\n\");\n        printf(\"\n1.Create List\t2.Status of list\t3.Insert End\t4.Delete End\t5.Insert Front\t6.Delete Front\t7.Double Ended Queue Demo\n8.Exit\nEnter your choice:\");\n        scanf(\"%d\",&ch);\n\n        switch (ch)\n        {\n        case 1:\n            create_list();\n            break;\n        \n        case 2:\n            status();\n            break;\n        \n        case 3:\n            insert_end();\n            break;\n        \n        case 4:\n            delete_end();\n            break;\n        \n        case 5:\n            insert_front();\n            break;\n\n        case 6:\n            delete_front();\n            break;\n\n        case 7:\n            double_ended_queue();\n            break;\n        \n        case 8:\n            return 0;\n\n        default:\n            printf(\"\nInvlid choice. Try again!\");\n            break;\n        }\n    }\n    return 0;"},
                        {"E9": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n\nstruct polynomial{\n    int coeff,x,y,z;\n    struct polynomial *link;\n};\n\ntypedef struct polynomial * P;\n\nP create(){\n    P gnode = (P)malloc(sizeof(struct polynomial));\n    if(gnode==NULL){\n        printf(\"\nThe memory could not be alocated.\");\n        return NULL;\n    }\n    return gnode;\n}\n\nP insert(P head,int c,int px,int py,int pz){\n    P node, temp;\n\n    node = create();\n    node->coeff = c;\n    node->x = px;\n    node->y = py;\n    node->z = pz;\n    node->link = NULL;\n    temp = head->link;\n    while(temp->link!=head){\n        temp = temp->link;\n    }\n\n    temp -> link = node;\n    node -> link = head;\n\n    return(head);\n}\n\nP input_poly(P head){\n    int i,c,px,py,pz;\n    printf(\"\nEnter 999 to end the polynomial!\");\n    for(i = 1; ; i++){\n        printf(\"\nEnter the coefficient %d: \",i);\n        scanf(\"%d\",&c);\n        if(c==999){\n            break;\n        }\n        printf(\"\nEnter the power of X: \");\n        scanf(\"%d\",&px);\n\n        printf(\"\nEnter the power of Y: \");\n        scanf(\"%d\",&py);\n\n        printf(\"\nEnter the power of Z: \");\n        scanf(\"%d\",&pz);\n\n        head = insert(head,c,px,py,pz);\n    }\n\n    return head;\n}\n\nvoid display(P head){\n    P temp;\n    if(head->link == head){\n        printf(\"\nPolynomial doesn't exist!\");\n    }\n    else{\n        temp = head->link;\n        while(temp!=head){\n            printf(\"%dx^%dy^%dz^%d+\",temp->coeff,temp->x,temp->y,temp->z);\n            temp = temp->link;\n        }\n        printf(\"999\");\n    }\n}\n\nint evaluate_polynomial(P head){\n    int vx,vy,vz,sum = 0;\n\n    P temp;\n    printf(\"\n\nEnter the value of x,y, and z: \");\n    scanf(\"%d%d%d\",&vx,&vy,&vz);\n    temp = head -> link;\n    while(temp!=head){\n        sum += (temp->coeff*pow(vx,temp->x)*pow(vy, temp->y)*pow(vz,temp->z));\n        temp = temp->link;\n    }\n    return sum;\n}\n\nint main(){\n    P head;\n    int res;\n\n    head = create();\n    head->link = head;\n\n    printf(\"\nEnter the polynomial to be evaluated: \");\n    head = input_poly(head);\n\n    printf(\"\nThe given polynomial is: \");\n    display(head);\n\n    res = evaluate_polynomial(head);\n\n    printf(\"\nThe result after evaluation: %d\",res);\n    return 0;\n}"},
                        {"E10": "#include<stdio.h>\n#include<stdlib.h>\n\nstruct tree{\n    int data;\n    struct tree * left, * right;\n};\n\ntypedef struct tree * T;\n\nT create(){\n    T node = (T)malloc(sizeof(struct tree));\n    if(node == NULL){\n        printf(\"\nMemoery not allocated.\");\n        return NULL;\n    }\n    return node;\n}\n\nT create_bst(T root){\n    T node,prev,cur;\n    node = create();\n    printf(\"\nEnter the data to be inserted: \");\n    scanf(\"%d\",&node->data);\n    node->left = NULL;\n    node->right = NULL;\n\n    if(root==NULL){\n        root = node;\n        return root;\n    }\n    prev = NULL;\n    cur  = root;\n\n    while(cur!=NULL){\n        prev = cur;\n\n        if(node->data < cur->data){\n            cur = cur->left;\n        }\n        else{\n            cur = cur->right;\n        }\n    }\n        if(node->data < prev->data){\n            prev->left = node;\n        }\n        else{\n            prev->right = node;\n        }\n\n     return root;\n}\n\nvoid iOt(T root){\n    if(root==NULL){\n        return;\n    }\n    iOt(root->left);\n    printf(\"%3d\",root->data);\n    iOt(root->right);\n}\n\nvoid pOt(T root){\n    if(root==NULL)\n        return;\n    printf(\"%3d\",root->data);\n    pOt(root->left);\n    pOt(root->right);\n}\n\nvoid pOSt(T root){\n    if(root==NULL)\n        return;\n    pOSt(root->left);\n    pOSt(root->right);\n    printf(\"%3d\",root->data);\n}\n\nvoid searchBST(T root){\n    int key,flag = 0;\n\n    T temp;\n    printf(\"\nEnter the key to be searched: \");\n    scanf(\"%d\",&key);\n\n    if(root==NULL){\n        return;\n    }\n    temp = root;\n    while(temp!=NULL){\n        if(key==temp->data){\n            flag = 1;\n            break;\n        }\n        else if(key<temp->data){\n            temp = temp->left;\n        }\n        else{\n            temp =  temp->right;\n        }\n    }\n\n    if(flag == 1){\n        printf(\"\nKey is found.\");\n    }\n    else \n        printf(\"\nKey is not found\");\n}   \n\nint main(){\n    int ch,n,i;\n\n    T root = NULL;\n\n    for(;;){\n        printf(\"\n------------------------Binary Search Tree Operations-----------------------\n\");\n        printf(\"\n1.Create N integers\t2.Inorder Traversal\t3.Pre-order Traversal\t4.Post Order traversal\n5.Search for a key\t6.Exit\nEnter your choice: \");\n        scanf(\"%d\",&ch);\n\n        switch (ch)\n        {\n        case 1:\n            printf(\"\nEnter the number of integers: \");\n            scanf(\"%d\",&n);\n            for(int i = 0;i<n;i++)\n                root = create_bst(root);\n            break;\n\n        case 2:\n            printf(\"\nThe inorder traversal is: \");\n            iOt(root);\n            break;\n        \n        case 3:\n            printf(\"\nThe pre-order traversal is: \");\n            pOt(root);\n            break;\n\n        case 4:\n            printf(\"\nThe Post order traversal is: \");\n            pOSt(root);\n            break;\n\n        case 5:\n            searchBST(root);\n            break;\n\n        case 6:\n            return 0;\n\n        default:\n            printf(\"\nInvalid choice!\");\n            break;\n        }\n    }\n\n    return 0;\n}"},
                        {"E11": "#include <stdio.h>\n#include <stdlib.h>\n\nint a[20][20],q[20],visited[20],reach[10],n,i,j,f=1,r=0,count=0;\n\nvoid bfs(int v)\n{\n\tfor(i=1;i<=n;i++)\n\t\tif(a[v][i] && !visited[i])\n\t\t\tq[++r]=i;\n\tif(f<=r)\n\t{\n\t\tvisited[q[f]]=1;\n\t\tbfs(q[f++]);\n\t}\n}\n\nvoid dfs(int v)\n{\n\tint i;\n\treach[v]=1;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(a[v][i] && !reach[i])\n\t\t{\n\t\t\tprintf(\"\\n %d->%d\",v,i);\n\t\t\tcount++;\n\t\t\tdfs(i);\n\t\t}\n\t}\n}\n\nvoid main()\n{\n\tint v, choice;\n\t//clrscr();\n\tprintf(\"\\n Enter the number of vertices:\");\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tq[i]=0;\n\t\tvisited[i]=0;\n\t}\n\tfor(i=1;i<=n-1;i++)\n\t\treach[i]=0;\n\t\t\n\tprintf(\"\\n Enter graph data in matrix form:\\n\");\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\tscanf(\"%d\",&a[i][j]);\n\twhile(1)\n\t{\n\t\tprintf(\"\\nMENU\\n1.BFS\\n2.DFS\\n3.Exit\\n\");\n\t\tscanf(\"%d\",&choice);\n\t\tswitch(choice)\n\t\t{\n\t\t\tcase 1: printf(\"\\n Enter the starting vertex:\");\n\t\t\t\tscanf(\"%d\",&v);\n\t\t\t\tbfs(v);\n\t\t\t\tprintf(\"\\n Nodes reachable from %d are:\\n\",v);\n\t\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\t\tif(visited[i]==1 && i!=v)\n\t\t\t\t\t\tprintf(\"\\n%d\\n\",i);\n\t\t\t\tbreak;\n\t\t\tcase 2:dfs(1);\n\t\t\t\tif(count==n-1)\n\t\t\t\t\tprintf(\"\\n Graph is connected\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"\\n Graph is not connected\");\n\t\t\t\tbreak;\n\t\t\tcase 3: exit(0);\n\t\t}\n\t\t\n\t}\n}"},
                        {"E12": "#include<stdio.h>\n#include<stdlib.h>\n\nint key[20],n,m;\n\nint *ht;\nint *index;\n\nint count = 0;\n\nvoid insert(int key){\n    index = key%m;\n\n    while(ht[index]!=1){\n        index = (index+1)%m;\n    }\n\n    ht[index] = key;\n    count++;\n}\n\nvoid display(){\n    int i;\n    if(count == 0){\n        printf(\"\\nHash table is empty\");\n        return;\n    }\n\n    printf(\"\\nHash Table contents are:\\n\");\n    for(i=0;i<m;i++)\n        printf(\"\\nT[%d] -> %d\",i,ht[i]);\n}\n\nvoid main(){\n    int i;\n    printf(\"\\nEnter the number of employee records(N): \");\n    scanf(\"%d\",&n);\n\n    printf(\"\\nEnter the two digit memory locations(m) for hash table: \");\n    scanf(\"%d\",&m);\n\n    ht = (int *)malloc(m*sizeof(int));\n\n    for(i=0;i<m;i++)\n        ht[i] = -1;\n\n    printf(\"\\nEnter the four digit key values(k) for N employee records: \\n\");\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&key[i]);\n    }\n\n    for(i=0;i<n;i++){\n        if(count == m){\n            printf(\"\\n~~~Hash table is full. Cannot insert the record %d key~~~\", i+1);\n            break;\n        }\n        insert(key[i]);\n    }\n\n    display();\n}"}
                        ]
            },
            {
                "Java":[{}]
            },
            {
                "DDCO":[{}]
            }]
        },
        {
            "4":[]
        },
        {
            "5":[]
        },
        {
            "6":[]
        },
        {
            "7":[]
        },
        {
            "8":[]
        }
    ]
}

export default codeObject;